//**Target Sum Based on 0-1 Knapsack Problem**//

#include <bits/stdc++.h>
using namespace std;

int countSubsets(vector<int>& nums, int sum) {
    int n = nums.size();
    int dp[n+1][sum+1];

    // Initialization
    for(int i=0; i<=n; i++)
        dp[i][0] = 1; // one way to make sum 0 â€” take nothing
    for(int j=1; j<=sum; j++)
        dp[0][j] = 0; // no elements but positive sum => 0 ways

    // DP filling
    for(int i=1; i<=n; i++) {
        for(int j=0; j<=sum; j++) {
            if(nums[i-1] <= j)
                dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j];
            else
                dp[i][j] = dp[i-1][j];
        }
    }

    return dp[n][sum];
}

int findTargetSumWays(vector<int>& nums, int target) {
    int totalSum = accumulate(nums.begin(), nums.end(), 0);

    if((totalSum + target) % 2 != 0 || totalSum < abs(target))
        return 0;

    int S1 = (totalSum + target) / 2;

    return countSubsets(nums, S1);
}

int main() {
    vector<int> nums = {1,1,2,3};
    int target = 1;

    cout << "Number of ways: " << findTargetSumWays(nums, target);
    return 0;
}
